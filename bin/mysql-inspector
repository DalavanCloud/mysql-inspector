#!/usr/bin/env ruby

$LOAD_PATH.unshift File.dirname(__FILE__) + '/../lib'
require 'optparse'
require "mysql_inspector"

CURRENT = "current"
TARGET  = "target"

@options = {
  :dir => ".",
  :database => nil
}

@opts = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename $0} [options] command [command args]"

  opts.separator ""
  opts.separator "Options"
  opts.separator ""

  opts.on("--db DATABASE", "Operate on DATABASE") do |database|
    @options[:database] = database
  end

  #opts.on("--to VERSION", "Perform the given action(s) with the VERSION (current or target).") do |version|
    #options[:version] = version
  #end

  opts.on("--out DIR", "Where to store schemas. Defaults to '.'") do |dir|
    @options[:dir] = dir
  end

  opts.on("-h", "--help", "What you're looking at") do
    opts.terminate
  end

  opts.on("-v", "--version", "Show the version of mysql-inspector") do
    puts MysqlInspector::VERSION
    exit
  end

  opts.separator ""
  opts.separator "Commands"
  opts.separator ""

  opts.separator "  write DATABASE [VERSION]"
  opts.separator "  diff"
  opts.separator "  diff TO"
  opts.separator "  diff FROM TO"
  opts.separator "  grep PATTERN [PATTERN]"
  opts.separator ""
end

@opts.parse!

abort @opts.to_s if ARGV.empty?

@database_name = @options[:database] or abort @opts.to_s

def dump_name(version)
  ["mysql", @database_name, version] * "_"
end

#dump_names = []
#dump_names.concat Dir[File.join(options[:dir], dump_name("*"))].map { |f|
  #regex = Regexp.new("^#{dump_name("(.*)")}$")
  #name = File.basename(f)
  #name[regex, 1]
#}
#dump_names << options[:version]

#@dumps = {}
#dump_names.compact.uniq.each { |name|
  #path = File.join(options[:dir], dump_name(name))
  #@dumps[name] = MysqlInspector::Dump.new(path, @database_name)
#}

# Print table details
def format_items(label, items, &formatter)
  pad = " " * 4
  formatter ||= proc { |item | item }
  items.each.with_index { |item, i|
    if i == 0
      puts [label, pad, formatter.call(item)] * ""
    else
      puts [" " * label.size, pad, formatter.call(item)] * ""
    end
  }
end

def usage(msg)
  abort "Usage: #{@opts.program_name} #{msg}"
end

def create_dump(name)
  path = File.join(@options[:dir], dump_name(name))
  MysqlInspector::Dump.new(path, @database_name)
end

command = ARGV.shift
case command

when "write", "create"
  database = ARGV.shift or usage "write DATABASE [VERSION]"
  version  = ARGV.shift || CURRENT
  dump = create_dump(version)
  begin
    dump.write!
  rescue MysqlInspector::Dump::WriteError => e
    abort e.message
  end

when "grep"
  dump = create_dump(CURRENT)
  dump.exists? or abort "Cannot grep because dump #{CURRENT.inspect} does not exist"

  matchers = *ARGV.map { |a| Regexp.new(a) }
  grep = MysqlInspector::Grep.new(dump, matchers)
  grep.execute

  puts "#{dump.db_name}@#{CURRENT}"
  puts
  puts "grep #{matchers.map { |m| m.inspect } * " AND "}"

  puts if grep.any_matches?

  grep.each_table { |table, subset|
    puts table.table_name
    format_items("COL", subset.columns)
    format_items("IDX", subset.indices)
    format_items("CST", subset.constraints)
    puts
  }

when "diff"
  dump1 = create_dump(CURRENT)
  dump1.exists? or abort "Cannot diff because no #{CURRENT.inspect} dump exists"
  dump2 = create_dump(TARGET)
  dump2.exists? or abort "Cannot diff because no #{TARGET.inspect} dump exists"

  diff = MysqlInspector::Diff.new(dump1, dump2)
  diff.execute

  puts "diff #{dump1.db_name}@#{CURRENT} #{dump2.db_name}@#{TARGET}"

  def prefix_for_table(table, diff)
    case
    when diff.added_tables.include?(table) then "+"
    when diff.missing_tables.include?(table) then "-"
    else "="
    end
  end

  def format_diff_items(label, added, removed)
    format_items(label, (added + removed).sort) { |item|
      prefix = added.include?(item) ? "+" : "-"
      "#{prefix} #{item}"
    }
  end

  tables = diff.added_tables + diff.missing_tables + diff.different_tables

  if tables.any?
    puts
    tables.sort.each do |t|
      prefix = prefix_for_table(t, diff)
      puts "#{prefix} #{t.table_name}"
      if t.is_a?(MysqlInspector::Diff::TableDiff)
        format_diff_items("  COL", t.added_columns, t.missing_columns)
        format_diff_items("  IDX", t.added_indices, t.missing_indices)
        format_diff_items("  CST", t.added_constraints, t.missing_constraints)
      end
    end
    puts
  end

else
  abort "Unknown command #{command.inspect}"
end
