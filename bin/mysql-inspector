#!/usr/bin/env ruby

$LOAD_PATH.unshift File.dirname(__FILE__) + '/../lib'
require 'optparse'
require "mysql_inspector"

options = {
  :dir => ".",
  :version => "current",
  :command => nil
}

opts = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename $0} [options] command [command args]"

  opts.separator ""
  opts.separator "Options"
  opts.separator ""

  opts.on("--db DATABASE", "Operate on DATABASE") do |database|
    options[:database] = database
  end

  opts.on("--to VERSION", "Perform the given action(s) with the VERSION (current or target).") do |version|
    options[:version] = version
  end

  opts.on("--out DIR", "Where to store schemas. Defaults to '.'") do |dir|
    options[:dir] = dir
  end

  opts.on("-h", "--help", "What you're looking at") do
    opts.terminate
  end

  opts.on("-v", "--version", "Show the version of mysql-inspector") do
    puts MysqlInspector::VERSION
    exit
  end

  opts.separator ""
  opts.separator "Commands"
  opts.separator ""

  opts.separator "  diff"
  opts.separator "  grep pattern [pattern]"
  opts.separator ""
end

opts.parse!

abort opts.to_s if ARGV.empty?

@database_name = options[:database] or abort opts.to_s
@current_version = options[:version] or abort opts.to_s

def dump_name(version)
  ["mysql", @database_name, version] * "_"
end

dump_names = []
dump_names.concat Dir[File.join(options[:dir], dump_name("*"))].map { |f|
  regex = Regexp.new("^#{dump_name("(.*)")}$")
  name = File.basename(f)
  name[regex, 1]
}
dump_names << options[:version]

@dumps = {}
dump_names.compact.uniq.each { |name|
  path = File.join(options[:dir], dump_name(name))
  @dumps[name] = MysqlInspector::Dump.new(path, @database_name)
}

# Print table details
def format_items(label, items, &formatter)
  pad = " " * 4
  formatter ||= proc { |item | item }
  items.each.with_index { |item, i|
    if i == 0
      puts [label, pad, formatter.call(item)] * ""
    else
      puts [" " * label.size, pad, formatter.call(item)] * ""
    end
  }
end

command = ARGV.shift
case command

when "write", "create"
  dump = @dumps[@current_version]
  begin
    dump.write!
  rescue MysqlInspector::Dump::WriteError => e
    abort e.message
  end

when "grep"
  dump = @dumps[@current_version]
  dump && dump.exists? or abort "Cannot grep because dump #{@current_version.inspect} does not exist"

  matchers = *ARGV.map { |a| Regexp.new(a) }
  grep = MysqlInspector::Grep.new(dump, matchers)
  grep.execute

  puts "#{dump.db_name}@#{@current_version}"
  puts
  puts "grep #{matchers.map { |m| m.inspect } * " AND "}"

  puts if grep.any_matches?

  grep.each_table { |table, subset|
    puts table.table_name
    format_items("COL", subset.columns)
    format_items("IDX", subset.indices)
    format_items("CST", subset.constraints)
    puts
  }

when "diff"
  dump1 = @dumps["current"]
  dump1 && dump1.exists? or abort "Cannot diff because no current dump exists"
  dump2 = @dumps["target"]
  dump2 && dump2.exists? or abort "Cannot diff because no target dump exists"

  diff = MysqlInspector::Diff.new(dump1, dump2)
  diff.execute

  puts "diff #{dump1.db_name}@current #{dump2.db_name}@target"

  def prefix_for_table(table, diff)
    case
    when diff.added_tables.include?(table) then "+"
    when diff.missing_tables.include?(table) then "-"
    else "="
    end
  end

  def format_diff_items(label, added, removed)
    format_items(label, (added + removed).sort) { |item|
      prefix = added.include?(item) ? "+" : "-"
      "#{prefix} #{item}"
    }
  end

  tables = diff.added_tables + diff.missing_tables + diff.different_tables

  if tables.any?
    puts
    tables.sort.each do |t|
      prefix = prefix_for_table(t, diff)
      puts "#{prefix} #{t.table_name}"
      if t.is_a?(MysqlInspector::Diff::TableDiff)
        format_diff_items("  COL", t.added_columns, t.missing_columns)
        format_diff_items("  IDX", t.added_indices, t.missing_indices)
        format_diff_items("  CST", t.added_constraints, t.missing_constraints)
      end
    end
    puts
  end

else
  abort "Unknown command #{command.inspect}"
end
