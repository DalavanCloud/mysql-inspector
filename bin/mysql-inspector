#!/usr/bin/env ruby

$LOAD_PATH.unshift File.dirname(__FILE__) + '/../lib'
require 'optparse'
require "mysql_inspector"

options = {
  :dir => ".",
  :version => "current",
  :command => nil
}

opts = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename $0} [options] command [command args]"

  opts.separator ""
  opts.separator "Options"
  opts.separator ""

  opts.on("--db DATABASE", "Operate on DATABASE") do |database|
    options[:database] = database
  end

  opts.on("--on VERSION", "Perform the given action(s) with the VERSION (current or target).") do |version|
    options[:version] = version
  end

  opts.on("--out DIR", "Where to store schemas. Defaults to '.'") do |dir|
    options[:dir] = dir
  end

  opts.on("-h", "--help", "What you're looking at") do
    opts.terminate
  end

  opts.on("-v", "--version", "Show the version of mysql-inspector") do
    puts MysqlInspector::VERSION
    exit
  end

  opts.separator ""
  opts.separator "Commands"
  opts.separator ""

  opts.separator "  diff"
  opts.separator "  grep pattern [pattern]"
  opts.separator ""
end

opts.parse!

abort opts.to_s if ARGV.empty?

@database_name = options[:database] or abort opts.to_s
@current_version = options[:version] or abort opts.to_s

def dump_name(version)
  ["mysql", @database_name, version] * "_"
end

@current_dump_name = dump_name(@current_version)

dump_names = []
dump_names.concat Dir[File.join(options[:dir], dump_name("*"))].map { |f|
  regex = Regexp.new("^#{dump_name("(.*)")}$")
  f[regex, 1]
}
dump_names << dump_name(options[:version])

@dumps = {}
dump_names.compact.uniq.each { |name|
  path = File.join(options[:dir], name)
  @dumps[name] = MysqlInspector::Dump.new(path, @database_name)
}

command = ARGV.shift
case command
when "write", "create"
  dump = @dumps[@current_dump_name]
  dump.write!
when "grep"
  dump = @dumps[@current_dump_name]
  dump.exists? or abort "Cannot grep because dump #{@current_version.inspect} does not exist"

  matchers = *ARGV.map { |a| Regexp.new(a) }
  grep = MysqlInspector::Grep.new(dump, matchers)
  grep.execute

  puts "#{dump.db_name}@#{@current_version}"
  puts
  puts "grep #{matchers.map { |m| m.inspect } * " AND "}"

  def format_items(items)
    items.map { |x| "  #{x.table.table_name}\n    #{x.to_s}" } * "\n"
  end

  if grep.any_matches?
    puts
    if grep.columns.any?
      puts "Columns"
      puts format_items(grep.columns)
      puts
    end
    if grep.indices.any?
      puts "Indices"
      puts format_items(grep.indices)
      puts
    end
    if grep.constraints.any?
      puts "Constraints"
      puts format_items(grep.constraints)
      puts
    end
  end

when "diff"
  nil
else
  abort "Unknown command #{command.inspect}"
end
